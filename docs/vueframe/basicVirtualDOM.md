### Vue VirtualDOM



#### 1. 权衡的艺术

> 在讨论 Virtual DOM 之前，有必要先讨论视图层框架设计方面的内容。本章内容参考 Vue.js 设计与实现

##### 1.1 命令式和声明式

从范式上来看，视图层框架通常分为 **命令式 ** 和 **声明式**



* 命令式 (**Jquery**)：描述的是“做事的过程”

  ```javascript
  $('#app') // 获取 div
  	.text('hello world') // 设置文本内容
  	.on('click', () => alert('ok')) // 绑定点击事件
  ```

  更加关注过程

* 声明式(**Vue** 、**React**)：更加关注结果

```vue
<div @click="() => alert('ok')">hello world</div>
```

##### 1.2 性能与可维护性的权衡

> 先抛出个结论：声明式代码的性能不优于命令式代码的性能

假设现在我们要将 div 标签的文本内容修改为 hello vue3 ，如果用命令式代码如何实现呢？

```javascript
// 直接调用相关命令操作
div.textContent = 'hello vue3' // 直接修改
```

思考一下，有没有其他办法让上面这句代码性能更好？答案是“没有”。理论上命令式代码可以做到极致的性能优化，因为我们明确指导那些发生了更改，只做必要的修改就行了。但声明式代码不一定做到这一点，因为它描述的是结果：

```vue
// 之前
<div @click="() => alert('ok')">hello world</div>
// 之后
<div @click="() => alert('ok')">hello vue3</div>
```

对于框架而言，为了实现最优的性能，它需要找到前后的差异并只更新变化的地方，最终完成这次更新的代码任然是：

```javascript
div.textContent = 'hello vue3' // 直接修改
```

如果我们把直接修改的性能消耗定义为A，把找出差异的性能消耗定义为B，那么：

* 命令式代码的更新性能消耗 = A

* 声明式代码的性能消耗 = B + A

###### 总结

* 框架本身就是封装了命令式代码才实现了面向用户的声明式
* 命令式代码开发时需要维护实现目标的整个过程（手动完成**DOM**元素的创建、更新、删除等工作）
* 而声明式展示的就是我们要的结果，框架设计者要做的就是**在保持可维护性的同时让性能损失最小化**



#### 2. 虚拟 DOM

> 为什么命令式性能优于声明式，我们还是需要命令式呢？

##### 2.1 什么是虚拟 DOM

Virtual DOM(虚拟 DOM)，是由普通的 JS 对象来描述 DOM 对象 

##### 2.2 为什么要使用虚拟 DOM

* 原生 DOM 操作方法需要手动创建、删除、修改大量的 DOM 元素并且可维护性差，心智负担大
* MVVM 框架解决视图和状态同步问题
* 模板引擎可以简化视图操作，没办法跟踪状态
* 虚拟 DOM 跟踪状态变化

* [使用虚拟 DOM 动机](https://github.com/Matt-Esch/virtual-dom)
  * 虚拟 DOM 可以维护程序的状态，跟踪上一次的状态
  * 通过比较前后两次状态差异更新真实 DOM



##### 2.3 虚拟 DOM 的作用

* 维护视图和状态的关系
* 复杂视图情况下提升渲染性能
* 跨平台
  * 浏览器平台渲染DOM
  * 服务端渲染 SSR(Nuxt.js/Next.js) 
  * 原生应用(Weex/React Native) 
  * 小程序(mpvue/uni-app)等



##### 2.4 虚拟 DOM 库 

###### 2.4.1 Snabbdom

* Vue.js 2.x 内部使用的虚拟 DOM 就是改造的 Snabbdom
* 通过模块可扩展
* 源码使用 TypeScript 开发
* 最快的 Virtual DOM 之一



###### 2.4.2 virtual-dom



#####  